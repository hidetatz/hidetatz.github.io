<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>CPU・最適化など</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="author" content="Hidetatz Yaginuma">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">

  <style>
    body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
    }
  </style>

  <link href="/markdown.css" rel="stylesheet"></link>
  <link href="/syntax.css" rel="stylesheet"></link>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>
<body class="markdown-body">
<p><a href="/">&lt;- ホーム</a></p>
<h1>CPU・最適化など</h1>
<h4>最終更新日: 2024/07/02</h4>
<p>cpu</p>
<h1>最適化</h1>
<h2>理論FLOPSの導出方法</h2>
<p>現代のIntelプロセッサの理論FLOPSを計算するにあたっては、次のような前提知識が必要になる。</p>
<h3>Intel プロセッサにおけるスループットとレイテンシ</h3>
<p>Intelの仕様書には、命令のスループットとレイテンシが載っている。</p>
<p>https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</p>
<p>このスループットとレイテンシは、アプリケーションとかの文脈と微妙に意味が異なる。</p>
<p>まず、Intelのプロセッサにおけるスループットの定義は、「同じ命令を続けて発効するときに何クロックサイクル待つか」である。例えばスループットが1なら、1クロックサイクルで1回その命令が実行できる。0.5なら、1クロックサイクルで2回その命令が実行できる。</p>
<p>つまり、数字が小さいほうが発行できる命令数が多いのだ。これは割と直感的ではないと思う。通常スループットと言うと、「単位時間あたりの処理できる量」を言い、数字が大きいほうが性能が高い。したがって、意味合いが逆になっている印象を受ける。このため、StackoverflowやAgner fogさんのブログなどでは、Intelプロセッサのスループットは「Reciprocal throughput（逆数スループット）」と言われていたりする。</p>
<p>レイテンシは、「その命令が発行されてから何クロックサイクルでその命令は完了するか」を意味している。たとえばレイテンシが4なら、その命令は発効されてから４クロックサイクル後に命令が処理したデータが使えるようになる。</p>
<p>さて、このレイテンシとスループットがわかれば、1命令でクロックサイクルがどれだけかかるかがわかるのだが、ここでよくある誤解が「スループット * レイテンシ = かかるクロック数/命令」である、というものだ。例えば、スループットが0.5、レイテンシが4の場合、0.5 * 4で、1回の命令で2クロックサイクルかかる、という計算。これはどうやら間違っている。</p>
<p>正しい計算は、スループットが0.5なので、つまり1回のクロックサイクルで2回実行できるから、1回の命令では0.5クロックサイクルかかる、というものだ。</p>
<p>たとえば周波数をNとしたとき、前者の計算だとコアごとのFlopsは0.5Nになるが、後者の計算では2Nになる。
つまり、Flopsを不当に低く見積もってしまう。</p>
<p>何故レイテンシを考慮に入れなくて良いかと言うと、レイテンシは「その命令が終わるまでにどのくらいのクロックサイクルがかかるか」を示しているだけで、前の命令が終わっていなくても後続の命令を発行することは可能なためだ。</p>
<p>逆に言うと、前の命令の結果を利用して次の命令を発行しなければいけない場合（これを「データに依存関係がある」などという）、前者の計算でも良いことになる。ただ、純粋な性能、Flopsに関して議論する場合はデータの依存関係を考慮しないため、後者の計算の方が良い。</p>
<h3>FMA命令</h3>
<p>というスループットとレイテンシの話を踏まえて。</p>
<p>Fused Multiply Add命令は、"a * b + c"を1回の命令で実行できる。専用の回路がハードウェアに実装されている。</p>
<p>Sky lakeアーキテクチャではFMA命令はレイテンシ4、スループット0.5とある。したがってFlops計算時はFMA命令は2 * クロック周波数回実行できるとみなす。
また、Flops計算時はFMAが積和演算する際の「積」と「和」を別でカウントしてよい（Flopsは演算回数を示しているから）ので、さらに* 2することになる。</p>
<h3>ベクトル命令</h3>
<p>ベクトル命令では、専用の容量の大きいレジスタにデータをまとめて入れてまとめて計算しまとめて取り出す、ということができる。
これはFMAと組み合わせることができる。したがって、Flopsを計算するときは「1回のFMA命令で何個のデータを同時に処理できるか」が重要になる。これはすなわち、ベクトル命令で使うレジスタのサイズのことである。</p>
<p>ベクトル命令には種類が色々あり、例えばAVX2では256ビット（単精度浮動小数が同時に8個乗せられる）、SSEでは128ビット（4個）、AVX512では512ビット（16個）など、プロセッサがどの命令をサポートしているかによって異なる。</p>
<h3>理論Flopsの導出</h3>
<p>ここまでの話がわかればFlops計算は簡単である。Flopsは「1クロックサイクルで発効できる命令数」 * 「クロック数」 * 「コア数」だ。</p>
<p>「1クロックサイクルで発効できる命令数」は、FMAとベクトル命令を使って最大限盛った値を使うことになっている。例えばAVX2をサポートしたプロセッサで、FMAのスループットが0.5、レイテンシが4の場合は:</p>
<p>2 (積和なので) * 2 (スループットが0.5なので) * (256 / 32) (AVX2は256ビットのレジスタが使えて、そこに32ビットの浮動小数が何個載るかを計算したい = 単精度浮動小数の場合のFlopsを知りたいので。倍精度の場合は64で割ればよい)</p>
<p>という式になる。長くなったが要は2 * 2 * 8で、1クロックサイクルで32回の単精度浮動小数を演算できることになる。</p>
<p>私が使ってるIntel Core i9-10900は論理コア数20、クロック周波数は通常時2.8GHz、ターボブースト時5.2GHzなので、理論Flopsは</p>
<ul>
<li>通常時: 2.8 * 20 * 32で1792GFlops</li>
<li>ターボブースト時: 5.2 * 20 * 32で3328GFlops</li>
</ul>
<p>になる。ただし、256ビットのベクトル命令を使いまくっているとクロック周波数が落ちる仕様なため、ターボブースト時の理論Flopsを出すのは100%不可能と考えて良いだろう (たぶん) 。</p>
<p>また、倍精度浮動小数の場合は、ベクトル命令で載せられる数が半分になると考えればよいので、Flopsの値も単純に半分になる。一般的にFlopsといった場合、64ビット浮動小数の演算数を言うような気がしなくもない。</p>
<p>また、上記計算では論理コア数を用いて計算しているが、これでよいのかがよくわからない。演算器は物理コアごとに1つなため、ハイパースレッディングが効いていても各スレッドは演算器を取り合ってしまうおそれがある。従って物理コアを計算に使ったほうが無難な値にはなりそうだが、各スレッドは並列実行可能なため、実際のFlopsの観測値にどう影響するかは不明。</p>
<h1>命令</h1>
<h2>CPUID</h2>
<p>CPUID命令はAMD64 ISAに含まれていて、CPUのモデルやファミリー、サポートされている機能（SSEやAVXなど）、キャッシュラインのサイズ等、CPUの情報をソフトウェアから取得するためのもの。CPU Identificationの略。</p>
<p>EAXレジスタに適切なパラメータをセットしてからCPUIDをコールすると、EAX、EBX、ECX、EDXにそれぞれ何かしらの値が入っているのでそれを使う。</p>
<h3>EAX = 0の場合</h3>
<p>通常、まずEAXに0を入れてコールするとEAXに入れても良い最大値がわかるためそこからスタートするようだが、戻ってきたEAX (手元では10進数で22) の意味がイマイチわかってない。
EAXに0を入れた場合、EBX、ECX、EDXにはベンダIDというプロセッサの製造者を示す値が入っている。これは12文字固定で、EBX、<strong>EDX</strong>、ECXの順番でアスキーコードになっているようだ。手元では「GenuineIntel」となった。</p>

<script src="/highlight.pack.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>